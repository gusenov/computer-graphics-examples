#include "ogldraw.h"
#include <QOpenGLFunctions>

OGLDraw::OGLDraw(QWidget *parent)
    : QOpenGLWidget(parent)
{
}

OGLDraw::~OGLDraw()
{
}

/*virtual*/void OGLDraw::initializeGL()
{
    QOpenGLFunctions* pFunc = QOpenGLContext::currentContext()->functions();

    // Устанавливается белый цвет для очистки буфера изображения.
    pFunc->glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
}

/*virtual*/void OGLDraw::resizeGL(int nWidth, int nHeight)
{
    // В OpenGL существуют две матрицы, применяющиеся для преобразования координат. Первая
    // - матрица моделирования (modelview matrix) - служит для задания положения объекта
    // и его ориентации, а вторая - матрица проектирования (projection matrix) - отвечает за
    // выбранный способ проектирования. Способ проектирования может быть либо ортогональным,
    // либо перспективным.

    // Функция glMatrixМode() устанавливает матрицу проектирования текущей
    // матрицей. Это означает, что все последующие преобразования будут влиять только на нее.
    glMatrixMode(GL_PROJECTION);

    // Вызовом функции glLoadIdentity() текущая матрица устанавливается в единичную.
    glLoadIdentity();

    // Метод resizeGL() - это самое удобное место, чтобы установить видовое окно (viewport).
    // Видовое окно устанавливается вызовом функции glViewport() и представляет собой прямоугольную
    // область в пределах окна виджета (окно в окне). В нашем случае видовое окно
    // совпадает со всей областью виджета.
    glViewport (0, 0, (GLint)nWidth, (GLint)nHeight);

    // Соотношение сторон видового окна задается параметрами функции glOrtho().
    glOrtho(0, 400,  // Первый и второй параметры задают положения левой и правой отсекающих плоскостей
            200, 0,  // третий и четвертый - верхней и нижней отсекающих плоскостей,
            -1, 1);  // пятый и шестой - передней и задней отсекающих плоскостей, соответственно.
}

/*virtual*/void OGLDraw::paintGL()
{
    // После очистки буферов изображения и глубины
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // осуществляется серия вызовов метода draw().
    // В этот метод передаются координаты х и у, с которых будет начинаться рисование фигуры.
    // Тип фигуры, как уже отмечалось ранее, передается третьим параметром:

    // тип GL_POINTS говорит о том, что отображаться должны только точки;
    draw(0, 0, GL_POINTS);

    // при построении фигуры типа GL_LINES каждая пара вершин задает отрезки, которые, как
    // правило, не соединяются друг с другом;
    draw(100, 0, GL_LINES);

    // тип GL_LINE_STRIP задает ломаную линию и используется, в основном, для аппроксимации
    // кривых. Если требуется получить замкнутый контур, то нужно указать одну и ту же
    // вершину в начале и в конце серии вершин;
    draw(200, 0, GL_LINE_STRIP);

    // тип GL_LINE_LOOP также задает ломаную линию, но последняя ее точка соединяется с первой;
    draw(300, 0, GL_LINE_LOOP);

    // тип GL_TRIANGLE_STRIP задает треугольники с общей стороной. Каждая вершина, начиная
    // с третьей, комбинируется с двумя предыдущими и определяет очередную ячейку;
    draw(0, 100, GL_TRIANGLE_STRIP);

    // тип GL_POLYGON задает многоугольник;
    draw(100, 100, GL_POLYGON);

    // при построении фигуры типа GL_QUADS каждые четыре вершины задают четырехугольник;
    draw(200, 100, GL_QUADS);

    // при построении фигуры типа GL_TRIANGLES каждые три вершины задают треугольник.
    draw(300, 100, GL_TRIANGLES);
}

// Осуществляет построение фигуры заданного типа type с позиции, определяемой переданными координатами.
void OGLDraw::draw(int xOffset, int yOffset, GLenum type)
{
    int n = 8;

    // Для задания размеров точки служит функция glPointSize().
    glPointSize(2);

    glBegin(type);

        // Функция glColor* () устанавливает черный цвет для вершин.
        glColor3f(0, 0, 0);

        for (int i = 0; i < n; ++i) {
            float fAngle = 2 * 3.14 * i / n;
            int х = (int) (50 + cos(fAngle) * 40 + xOffset);
            int у = (int) (50 + sin(fAngle) * 40 + yOffset);

            // Вызов функции glVertex*() задает расположение вершин.
            glVertex2f(х, у);
        }
    glEnd();
}
