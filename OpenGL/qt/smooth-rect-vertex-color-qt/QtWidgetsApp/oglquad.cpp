#include "oglquad.h"
#include <QOpenGLFunctions>

OGLQuad::OGLQuad(QWidget *parent)
    : QOpenGLWidget(parent)
{
}

OGLQuad::~OGLQuad()
{
}

// Метод initializeGL() вызывается сразу после создания объекта. Это требуется для проведения
// инициализаций, связанных с OpenGL. Метод вызывается, если объекту, унаследованному
// от класса QOpenGLWidget, присваивается контекст OpenGL.
/*virtual*/void OGLQuad::initializeGL()
{
    // Получаем при помощи статического метода currentContext() класса
    // QOpenGLContext() доступ к текущему контексту OpenGL и методом functions() - к его
    // функциям.
    // Контекст OpenGL - это набор переменных состояния, и каждый объект класса
    // QOpenGLWidget создает его автоматически.
    QOpenGLFunctions* pFunc = QOpenGLContext::currentContext()->functions();

    pFunc->glClearColor(0.0f, 0.0f, 0.0f, 1.0f);  // устанавливается цвет для очистки буфера изображения в формате OpenGL.
}

// Назначение метода resizeGL(int width, int height) схоже с назначением метода обработки
// события изменения размера resizeEvent(). Этот метод вызывается при изменении размеров
// объекта, созданного от класса, наследующего QOpenGLWidget. В параметрах метода
// передаются актуальные размеры виджета.
/*virtual*/void OGLQuad::resizeGL(int nWidth, int nHeight)
{
    // В OpenGL существуют две матрицы, применяющиеся для преобразования координат. Первая
    // - матрица моделирования (modelview matrix) - служит для задания положения объекта
    // и его ориентации, а вторая - матрица проектирования (projection matrix) - отвечает за
    // выбранный способ проектирования. Способ проектирования может быть либо ортогональным,
    // либо перспективным.

    glMatrixMode(GL_PROJECTION);  // устанавливает матрицу проектирования текущей матрицей.
    // Это означает, что все последующие преобразования будут влиять только на нее.

    glLoadIdentity();  // текущая матрица устанавливается в единичную.

    // Метод resizeGL() - это самое удобное место, чтобы установить видовое окно (viewport).
    // Видовое окно устанавливается вызовом функции glViewport() и представляет собой прямоугольную
    // область в пределах окна виджета (окно в окне). В нашем случае видовое окно
    // совпадает со всей областью виджета.
    glViewport(0, 0, static_cast<GLint>(nWidth), static_cast<GLint>(nHeight));

    // Соотношение сторон видового окна задается параметрами функции glOrtho().
    glOrtho(0, 100,  // положения левой и правой отсекающих плоскостей
            100, 0,  // верхней и нижней отсекающих плоскостей
            -1, 1);  // передней и задней отсекающих плоскостей
}

// Назначение метода paintGL() схоже с назначением метода обработки события рисования
// paintEvent(). Метод вызывается в тех случаях, когда требуется заново перерисовать содержимое
// виджета. Это происходит, например, после вызова
// метода resizeGL().
/*virtual*/void OGLQuad::paintGL()
{
    // Перед формированием нового изображения нужно функцией glClear() очистить буферы
    // изображения (GL_COLOR_BUFFER_BIT) и глубины (GL_DEPTH_BUFFER_BIT). Последний служит
    // для удаления невидимых поверхностей. Для очистки буфера изображения будет использован
    // цвет, установленный методом glClearColor().
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // Единица информации OpenGL - вершина. Из вершин строятся сложные объекты, при создании
    // которых нужно указать, каким образом они должны быть соединены друг с другом.
    // Способом соединения вершин управляет функция glBegin (). В нашем примере флаг
    // GL_QUADS говорит о том, что на создаваемых вершинах должен быть построен четырехугольник.
    glBegin(GL_QUADS);

        // При помощи функции glColor*() задается текущий цвет, который
        // распространяется на последующие вызовы функций glVertex*(), задающих расположение
        // вершин. Функции задания вершин должны всегда находиться между glBegin() и glEnd().

        glColor3f(1, 0, 0);
        glVertex2f(0, 100);

        glColor3f(0, 1, 0);
        glVertex2f(100, 100);

        glColor3f(0, 0, 1);
        glVertex2f(100, 0);

        glColor3f(1, 1, 1);
        glVertex2f(0, 0);

        // В нашем примере каждая вершина имеет свой цвет, и, поскольку по умолчанию в OpenGL
        // включен режим сглаживания цветов, это приводит к созданию радужной окраски области
        // прямоугольника. Режимом сглаживания цветов управляет функция glShadeModel(). Ее вызов
        // с флагом GL_FLAT отключает режим сглаживания, а передача флага GL_SMOOTH включает
        // его.
    glEnd();
}
